import os
import html
import argparse # For command-line arguments

# --- Configuration (Defaults, can be overridden by CLI args) ---
DEFAULT_REPO_NAME = "Repository Showcase"
DEFAULT_REPO_DESCRIPTION = "Code and files from a Git repository."
DEFAULT_REPO_URL = "#" # Placeholder, should be provided
DEFAULT_LOCAL_REPO_PATH = "." # Default source of files
DEFAULT_INDEX_TEMPLATE_PATH = "index.html"
DEFAULT_OUTPUT_HTML_PATH = "generated_index.html"

# --- Helper Functions ---

def get_repository_files(repo_path):
    """
    Lists files and directories in the repository.
    Ignores .git directory and other common unnecessary files/dirs.
    Returns a list of relative paths.
    """
    items = []
    # More robust ignore list, especially for when scanning subdirectories like 'cloned_repo'
    # These script names are less relevant to ignore when scanning a *different* directory.
    base_ignore_list = ['.git', '.idea', '__pycache__']
    # Add more if needed, e.g. specific large files, build artifacts if not in .gitignore of target repo

    for root, dirs, files in os.walk(repo_path, topdown=True):
        # Modify dirs in-place to skip ignored directories
        dirs[:] = [d for d in dirs if d not in base_ignore_list and not d.startswith('.')]

        for name in files:
            if name not in base_ignore_list and not name.startswith('.'):
                full_path = os.path.join(root, name)
                relative_path = os.path.relpath(full_path, repo_path)
                items.append(relative_path)

        for name in dirs: # Also list directories
            full_path = os.path.join(root, name)
            relative_path = os.path.relpath(full_path, repo_path) + os.sep
            items.append(relative_path)

    items.sort()
    return items

def read_file_content(filepath, repo_scan_path):
    """Reads the content of a specific file, ensuring it's within the scanned repo path."""
    # This check is a basic security measure if paths could be manipulated.
    # For this script, file_path is generated by get_repository_files, so it's already relative to repo_scan_path.
    # However, constructing full_path safely is good.
    absolute_repo_scan_path = os.path.abspath(repo_scan_path)
    full_target_path = os.path.abspath(os.path.join(repo_scan_path, filepath))

    if not full_target_path.startswith(absolute_repo_scan_path):
        print(f"Security warning: Attempt to read file outside of repository path: {filepath}")
        return "Error: Access denied."

    try:
        with open(full_target_path, 'r', encoding='utf-8', errors='ignore') as f:
            return f.read()
    except Exception as e:
        print(f"Error reading file {full_target_path}: {e}")
        return f"Error reading file: {e}"

def generate_file_list_html(files): # repo_path no longer needed here, path is for display
    """Generates HTML list items for the files."""
    if not files:
        return "<li>No files found in the repository.</li>"

    list_items_html = []
    for file_path in files:
        link_id = html.escape(file_path.replace(os.sep, "-").replace(".", "_").replace(" ", "_"))
        list_items_html.append(
            f'<li><a href="#{link_id}" data-filepath="{html.escape(file_path)}">{html.escape(file_path)}</a></li>'
        )
    return "\n".join(list_items_html)

def generate_file_content_sections_html(files, repo_scan_path):
    """Generates HTML sections for each file's content."""
    content_sections_html = []
    for file_path in files:
        if file_path.endswith(os.sep): # Skip directories for content display
            continue

        content = read_file_content(file_path, repo_scan_path) # Pass both relative and base path
        escaped_content = html.escape(content)

        section_id = html.escape(file_path.replace(os.sep, "-").replace(".", "_").replace(" ", "_"))

        content_sections_html.append(f"""
        <section class="file-content" id="{section_id}">
            <h3>{html.escape(file_path)}</h3>
            <pre><code>{escaped_content}</code></pre>
        </section>
        """)
    return "\n".join(content_sections_html)

def main():
    parser = argparse.ArgumentParser(description="Generate an HTML page from a repository's files.")
    parser.add_argument("repo_path", nargs='?', default=DEFAULT_LOCAL_REPO_PATH,
                        help="Path to the local repository directory to scan.")
    parser.add_argument("output_html_path", nargs='?', default=DEFAULT_OUTPUT_HTML_PATH,
                        help="Path to save the generated HTML file.")
    parser.add_argument("repo_name", nargs='?', default=DEFAULT_REPO_NAME,
                        help="Name of the repository.")
    parser.add_argument("repo_description", nargs='?', default=DEFAULT_REPO_DESCRIPTION,
                        help="Description of the repository.")
    parser.add_argument("repo_url", nargs='?', default=DEFAULT_REPO_URL,
                        help="URL of the repository.")
    parser.add_argument("--template", default=DEFAULT_INDEX_TEMPLATE_PATH,
                        help="Path to the HTML template file.")

    args = parser.parse_args()

    print(f"Reading HTML template from: {args.template}")
    try:
        with open(args.template, 'r', encoding='utf-8') as f:
            template_content = f.read()
    except FileNotFoundError:
        print(f"Error: Template file '{args.template}' not found.")
        # Simplified error handling: if template is missing, just exit.
        # The dummy creation logic was more for standalone testing.
        return

    print(f"Scanning repository files in: {args.repo_path}")
    if not os.path.isdir(args.repo_path):
        print(f"Error: Repository path '{args.repo_path}' not found or not a directory.")
        return

    repo_files = get_repository_files(args.repo_path)

    print(f"Found {len(repo_files)} files/directories.")

    file_list_html = generate_file_list_html(repo_files) # repo_path was for constructing full paths, now handled in read_file_content
    file_content_sections_html = generate_file_content_sections_html(repo_files, args.repo_path)

    output_content = template_content.replace("{repo_name}", html.escape(args.repo_name))
    output_content = output_content.replace("{repo_description}", html.escape(args.repo_description))
    output_content = output_content.replace("{repo_link}", html.escape(args.repo_url))
    output_content = output_content.replace("<!-- File items will be dynamically inserted here by Python -->", file_list_html)

    # This replacement assumes the exact structure of the placeholder section.
    # It's safer to use a more unique placeholder string if the template is complex.
    # For example, <!-- ALL_FILE_CONTENTS_GO_HERE -->
    # For now, the existing replacement logic for the section is kept.
    output_content = output_content.replace(
        """<section class="file-content" id="file-content-section" style="display:none;">
            <h3><span id="current-file-path"></span></h3>
            <pre><code id="code-display"></code></pre>
        </section>""",
        file_content_sections_html
    )

    # Check if the content to be written is different from the existing file
    # to minimize unnecessary rewrites (as per original user request).
    existing_content = ""
    if os.path.exists(args.output_html_path):
        try:
            with open(args.output_html_path, 'r', encoding='utf-8') as f_old:
                existing_content = f_old.read()
        except IOError:
            pass # Ignore if can't read old file, just overwrite

    if existing_content == output_content:
        print(f"Generated content is identical to '{args.output_html_path}'. No rewrite needed.")
    else:
        print(f"Writing generated HTML to: {args.output_html_path}")
        try:
            with open(args.output_html_path, 'w', encoding='utf-8') as f:
                f.write(output_content)
            print(f"Successfully generated '{args.output_html_path}'.")
        except IOError as e:
            print(f"Error writing output file: {e}")

if __name__ == "__main__":
    main()
